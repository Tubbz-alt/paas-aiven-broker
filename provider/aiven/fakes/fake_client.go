// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/alphagov/paas-aiven-broker/provider/aiven"
)

type FakeClient struct {
	CreateServiceStub        func(*aiven.CreateServiceInput) (string, error)
	createServiceMutex       sync.RWMutex
	createServiceArgsForCall []struct {
		arg1 *aiven.CreateServiceInput
	}
	createServiceReturns struct {
		result1 string
		result2 error
	}
	createServiceReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	CreateServiceUserStub        func(*aiven.CreateServiceUserInput) (string, error)
	createServiceUserMutex       sync.RWMutex
	createServiceUserArgsForCall []struct {
		arg1 *aiven.CreateServiceUserInput
	}
	createServiceUserReturns struct {
		result1 string
		result2 error
	}
	createServiceUserReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	DeleteServiceStub        func(*aiven.DeleteServiceInput) error
	deleteServiceMutex       sync.RWMutex
	deleteServiceArgsForCall []struct {
		arg1 *aiven.DeleteServiceInput
	}
	deleteServiceReturns struct {
		result1 error
	}
	deleteServiceReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteServiceUserStub        func(*aiven.DeleteServiceUserInput) (string, error)
	deleteServiceUserMutex       sync.RWMutex
	deleteServiceUserArgsForCall []struct {
		arg1 *aiven.DeleteServiceUserInput
	}
	deleteServiceUserReturns struct {
		result1 string
		result2 error
	}
	deleteServiceUserReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetServiceStub        func(*aiven.GetServiceInput) (*aiven.Service, error)
	getServiceMutex       sync.RWMutex
	getServiceArgsForCall []struct {
		arg1 *aiven.GetServiceInput
	}
	getServiceReturns struct {
		result1 *aiven.Service
		result2 error
	}
	getServiceReturnsOnCall map[int]struct {
		result1 *aiven.Service
		result2 error
	}
	UpdateServiceStub        func(*aiven.UpdateServiceInput) (string, error)
	updateServiceMutex       sync.RWMutex
	updateServiceArgsForCall []struct {
		arg1 *aiven.UpdateServiceInput
	}
	updateServiceReturns struct {
		result1 string
		result2 error
	}
	updateServiceReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) CreateService(arg1 *aiven.CreateServiceInput) (string, error) {
	fake.createServiceMutex.Lock()
	ret, specificReturn := fake.createServiceReturnsOnCall[len(fake.createServiceArgsForCall)]
	fake.createServiceArgsForCall = append(fake.createServiceArgsForCall, struct {
		arg1 *aiven.CreateServiceInput
	}{arg1})
	fake.recordInvocation("CreateService", []interface{}{arg1})
	fake.createServiceMutex.Unlock()
	if fake.CreateServiceStub != nil {
		return fake.CreateServiceStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createServiceReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) CreateServiceCallCount() int {
	fake.createServiceMutex.RLock()
	defer fake.createServiceMutex.RUnlock()
	return len(fake.createServiceArgsForCall)
}

func (fake *FakeClient) CreateServiceCalls(stub func(*aiven.CreateServiceInput) (string, error)) {
	fake.createServiceMutex.Lock()
	defer fake.createServiceMutex.Unlock()
	fake.CreateServiceStub = stub
}

func (fake *FakeClient) CreateServiceArgsForCall(i int) *aiven.CreateServiceInput {
	fake.createServiceMutex.RLock()
	defer fake.createServiceMutex.RUnlock()
	argsForCall := fake.createServiceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) CreateServiceReturns(result1 string, result2 error) {
	fake.createServiceMutex.Lock()
	defer fake.createServiceMutex.Unlock()
	fake.CreateServiceStub = nil
	fake.createServiceReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateServiceReturnsOnCall(i int, result1 string, result2 error) {
	fake.createServiceMutex.Lock()
	defer fake.createServiceMutex.Unlock()
	fake.CreateServiceStub = nil
	if fake.createServiceReturnsOnCall == nil {
		fake.createServiceReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.createServiceReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateServiceUser(arg1 *aiven.CreateServiceUserInput) (string, error) {
	fake.createServiceUserMutex.Lock()
	ret, specificReturn := fake.createServiceUserReturnsOnCall[len(fake.createServiceUserArgsForCall)]
	fake.createServiceUserArgsForCall = append(fake.createServiceUserArgsForCall, struct {
		arg1 *aiven.CreateServiceUserInput
	}{arg1})
	fake.recordInvocation("CreateServiceUser", []interface{}{arg1})
	fake.createServiceUserMutex.Unlock()
	if fake.CreateServiceUserStub != nil {
		return fake.CreateServiceUserStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createServiceUserReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) CreateServiceUserCallCount() int {
	fake.createServiceUserMutex.RLock()
	defer fake.createServiceUserMutex.RUnlock()
	return len(fake.createServiceUserArgsForCall)
}

func (fake *FakeClient) CreateServiceUserCalls(stub func(*aiven.CreateServiceUserInput) (string, error)) {
	fake.createServiceUserMutex.Lock()
	defer fake.createServiceUserMutex.Unlock()
	fake.CreateServiceUserStub = stub
}

func (fake *FakeClient) CreateServiceUserArgsForCall(i int) *aiven.CreateServiceUserInput {
	fake.createServiceUserMutex.RLock()
	defer fake.createServiceUserMutex.RUnlock()
	argsForCall := fake.createServiceUserArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) CreateServiceUserReturns(result1 string, result2 error) {
	fake.createServiceUserMutex.Lock()
	defer fake.createServiceUserMutex.Unlock()
	fake.CreateServiceUserStub = nil
	fake.createServiceUserReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateServiceUserReturnsOnCall(i int, result1 string, result2 error) {
	fake.createServiceUserMutex.Lock()
	defer fake.createServiceUserMutex.Unlock()
	fake.CreateServiceUserStub = nil
	if fake.createServiceUserReturnsOnCall == nil {
		fake.createServiceUserReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.createServiceUserReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeleteService(arg1 *aiven.DeleteServiceInput) error {
	fake.deleteServiceMutex.Lock()
	ret, specificReturn := fake.deleteServiceReturnsOnCall[len(fake.deleteServiceArgsForCall)]
	fake.deleteServiceArgsForCall = append(fake.deleteServiceArgsForCall, struct {
		arg1 *aiven.DeleteServiceInput
	}{arg1})
	fake.recordInvocation("DeleteService", []interface{}{arg1})
	fake.deleteServiceMutex.Unlock()
	if fake.DeleteServiceStub != nil {
		return fake.DeleteServiceStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteServiceReturns
	return fakeReturns.result1
}

func (fake *FakeClient) DeleteServiceCallCount() int {
	fake.deleteServiceMutex.RLock()
	defer fake.deleteServiceMutex.RUnlock()
	return len(fake.deleteServiceArgsForCall)
}

func (fake *FakeClient) DeleteServiceCalls(stub func(*aiven.DeleteServiceInput) error) {
	fake.deleteServiceMutex.Lock()
	defer fake.deleteServiceMutex.Unlock()
	fake.DeleteServiceStub = stub
}

func (fake *FakeClient) DeleteServiceArgsForCall(i int) *aiven.DeleteServiceInput {
	fake.deleteServiceMutex.RLock()
	defer fake.deleteServiceMutex.RUnlock()
	argsForCall := fake.deleteServiceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) DeleteServiceReturns(result1 error) {
	fake.deleteServiceMutex.Lock()
	defer fake.deleteServiceMutex.Unlock()
	fake.DeleteServiceStub = nil
	fake.deleteServiceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteServiceReturnsOnCall(i int, result1 error) {
	fake.deleteServiceMutex.Lock()
	defer fake.deleteServiceMutex.Unlock()
	fake.DeleteServiceStub = nil
	if fake.deleteServiceReturnsOnCall == nil {
		fake.deleteServiceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteServiceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteServiceUser(arg1 *aiven.DeleteServiceUserInput) (string, error) {
	fake.deleteServiceUserMutex.Lock()
	ret, specificReturn := fake.deleteServiceUserReturnsOnCall[len(fake.deleteServiceUserArgsForCall)]
	fake.deleteServiceUserArgsForCall = append(fake.deleteServiceUserArgsForCall, struct {
		arg1 *aiven.DeleteServiceUserInput
	}{arg1})
	fake.recordInvocation("DeleteServiceUser", []interface{}{arg1})
	fake.deleteServiceUserMutex.Unlock()
	if fake.DeleteServiceUserStub != nil {
		return fake.DeleteServiceUserStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deleteServiceUserReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) DeleteServiceUserCallCount() int {
	fake.deleteServiceUserMutex.RLock()
	defer fake.deleteServiceUserMutex.RUnlock()
	return len(fake.deleteServiceUserArgsForCall)
}

func (fake *FakeClient) DeleteServiceUserCalls(stub func(*aiven.DeleteServiceUserInput) (string, error)) {
	fake.deleteServiceUserMutex.Lock()
	defer fake.deleteServiceUserMutex.Unlock()
	fake.DeleteServiceUserStub = stub
}

func (fake *FakeClient) DeleteServiceUserArgsForCall(i int) *aiven.DeleteServiceUserInput {
	fake.deleteServiceUserMutex.RLock()
	defer fake.deleteServiceUserMutex.RUnlock()
	argsForCall := fake.deleteServiceUserArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) DeleteServiceUserReturns(result1 string, result2 error) {
	fake.deleteServiceUserMutex.Lock()
	defer fake.deleteServiceUserMutex.Unlock()
	fake.DeleteServiceUserStub = nil
	fake.deleteServiceUserReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeleteServiceUserReturnsOnCall(i int, result1 string, result2 error) {
	fake.deleteServiceUserMutex.Lock()
	defer fake.deleteServiceUserMutex.Unlock()
	fake.DeleteServiceUserStub = nil
	if fake.deleteServiceUserReturnsOnCall == nil {
		fake.deleteServiceUserReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.deleteServiceUserReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetService(arg1 *aiven.GetServiceInput) (*aiven.Service, error) {
	fake.getServiceMutex.Lock()
	ret, specificReturn := fake.getServiceReturnsOnCall[len(fake.getServiceArgsForCall)]
	fake.getServiceArgsForCall = append(fake.getServiceArgsForCall, struct {
		arg1 *aiven.GetServiceInput
	}{arg1})
	fake.recordInvocation("GetService", []interface{}{arg1})
	fake.getServiceMutex.Unlock()
	if fake.GetServiceStub != nil {
		return fake.GetServiceStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getServiceReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetServiceCallCount() int {
	fake.getServiceMutex.RLock()
	defer fake.getServiceMutex.RUnlock()
	return len(fake.getServiceArgsForCall)
}

func (fake *FakeClient) GetServiceCalls(stub func(*aiven.GetServiceInput) (*aiven.Service, error)) {
	fake.getServiceMutex.Lock()
	defer fake.getServiceMutex.Unlock()
	fake.GetServiceStub = stub
}

func (fake *FakeClient) GetServiceArgsForCall(i int) *aiven.GetServiceInput {
	fake.getServiceMutex.RLock()
	defer fake.getServiceMutex.RUnlock()
	argsForCall := fake.getServiceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) GetServiceReturns(result1 *aiven.Service, result2 error) {
	fake.getServiceMutex.Lock()
	defer fake.getServiceMutex.Unlock()
	fake.GetServiceStub = nil
	fake.getServiceReturns = struct {
		result1 *aiven.Service
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetServiceReturnsOnCall(i int, result1 *aiven.Service, result2 error) {
	fake.getServiceMutex.Lock()
	defer fake.getServiceMutex.Unlock()
	fake.GetServiceStub = nil
	if fake.getServiceReturnsOnCall == nil {
		fake.getServiceReturnsOnCall = make(map[int]struct {
			result1 *aiven.Service
			result2 error
		})
	}
	fake.getServiceReturnsOnCall[i] = struct {
		result1 *aiven.Service
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdateService(arg1 *aiven.UpdateServiceInput) (string, error) {
	fake.updateServiceMutex.Lock()
	ret, specificReturn := fake.updateServiceReturnsOnCall[len(fake.updateServiceArgsForCall)]
	fake.updateServiceArgsForCall = append(fake.updateServiceArgsForCall, struct {
		arg1 *aiven.UpdateServiceInput
	}{arg1})
	fake.recordInvocation("UpdateService", []interface{}{arg1})
	fake.updateServiceMutex.Unlock()
	if fake.UpdateServiceStub != nil {
		return fake.UpdateServiceStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateServiceReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) UpdateServiceCallCount() int {
	fake.updateServiceMutex.RLock()
	defer fake.updateServiceMutex.RUnlock()
	return len(fake.updateServiceArgsForCall)
}

func (fake *FakeClient) UpdateServiceCalls(stub func(*aiven.UpdateServiceInput) (string, error)) {
	fake.updateServiceMutex.Lock()
	defer fake.updateServiceMutex.Unlock()
	fake.UpdateServiceStub = stub
}

func (fake *FakeClient) UpdateServiceArgsForCall(i int) *aiven.UpdateServiceInput {
	fake.updateServiceMutex.RLock()
	defer fake.updateServiceMutex.RUnlock()
	argsForCall := fake.updateServiceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) UpdateServiceReturns(result1 string, result2 error) {
	fake.updateServiceMutex.Lock()
	defer fake.updateServiceMutex.Unlock()
	fake.UpdateServiceStub = nil
	fake.updateServiceReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdateServiceReturnsOnCall(i int, result1 string, result2 error) {
	fake.updateServiceMutex.Lock()
	defer fake.updateServiceMutex.Unlock()
	fake.UpdateServiceStub = nil
	if fake.updateServiceReturnsOnCall == nil {
		fake.updateServiceReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.updateServiceReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createServiceMutex.RLock()
	defer fake.createServiceMutex.RUnlock()
	fake.createServiceUserMutex.RLock()
	defer fake.createServiceUserMutex.RUnlock()
	fake.deleteServiceMutex.RLock()
	defer fake.deleteServiceMutex.RUnlock()
	fake.deleteServiceUserMutex.RLock()
	defer fake.deleteServiceUserMutex.RUnlock()
	fake.getServiceMutex.RLock()
	defer fake.getServiceMutex.RUnlock()
	fake.updateServiceMutex.RLock()
	defer fake.updateServiceMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ aiven.Client = new(FakeClient)
